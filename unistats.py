# -*- coding: utf-8 -*-
"""Unistats

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jnEcobf3GwhiMPERgU8-EJkgdeML8XZW

# Load Modules
"""

import matplotlib.pyplot as plt
import re
import geopandas as gpd
import numpy as np
import seaborn as sns
import zipfile
import seaborn as sns
import os

"""# Load Datasets"""

# Load the dataset
# Instituiton Dataset from HESA
institution_dataset = pd.read_csv('INSTITUTION.csv')
# Postcode Lookup Dataset
pcd_dataset = pd.read_csv('/content/drive/My Drive/Dissertation/PCD_OA_LSOA_MSOA_LAD_AUG22_UK_LU.csv', encoding='latin-1')
# Achievement Dataset from HESA
institution_grades = pd.read_csv('/content/drive/My Drive/Dissertation/Unistats Dataset/institution_grades.csv')
# IMD dataset from ONS
file_path = pd.read_csv("Indices_of_Multiple_Deprivation_(IMD)_2019.csv")
# Population Estimates from ONS
sape_data = pd.read_excel('SAPE22DT2-mid-2019-lsoa-syoa-estimates-unformatted.xlsx', sheet_name='Mid-2019 Persons')
# Electricity Dataset from HESA
data_year = pd.read_excel("LSOA_domestic_elec_2010-21.xlsx")
# Load the datasets
sheffield_boundaries = gpd.read_file("LSOA_2011_EW_BGC_V3.shp")

institution_modified = pd.read_csv('institution_modified.csv')
merged_data = pd.read_csv('merged_data_2015_2019.csv')
pcd_mapper = pd.read_csv('/content/drive/My Drive/Dissertation/pcd_mapper.csv')

electricity_data = merged_data

"""# Pre-Processing - Functions"""

# Define a function to extract the outcode from an address
def extract_outcode(address):
    # Check if the address is a string before attempting to split it
    if isinstance(address, str):
        # Regular expression pattern to find UK outcodes
        pattern = re.compile(r'[A-Z]{1,2}[0-9R][0-9A-Z]?')
        # Search for the pattern at the end of the address string
        match = pattern.search(address.split(',')[-1])
        return match.group() if match else None
    else:
        # If the address is not a string, return None
        return None

def to_csv(df, filename):
  # Save DataFrame to CSV file
  df.to_csv(f'{filename}.csv', index=False)

# Function to find UK postcodes in a string
def find_postcode(address):
    if isinstance(address, str):
        postcode_regex = r"[A-Za-z]{1,2}[0-9Rr][0-9A-Za-z]? ?[0-9][ABD-HJLNP-UW-Zabd-hjlnp-uw-z]{2}"
        postcode_search = re.search(postcode_regex, address)
        if postcode_search:
            return postcode_search.group()
    return None

"""# Plot Map"""

# Function to plot maps for top 5 LADs for each socio-economic factor with index scores and different colors
def plot_top_5_map_updated_v2(data, column, title):
    # Create a new column to highlight the top 5 LADs
    data['highlight'] = data[column].rank(ascending=False) <= 5
    top_5_data = data[data['highlight']].copy()

    # Sort the top 5 LADs by index score
    top_5_data = top_5_data.sort_values(by=column, ascending=False)

    # Generate color palette
    colors = sns.color_palette('tab10', n_colors=5)

    # Plot the map
    fig, ax = plt.subplots(figsize=(12, 6))
    data[~data['highlight']].plot(ax=ax, color='lightgrey', edgecolor='black', linewidth=0.5)

    # Plot each LAD in top 5 with different color and label
    labels = []
    for i, row in enumerate(top_5_data.iterrows()):
        _, row = row
        data[data['lad20nm'] == row['lad20nm']].plot(ax=ax, color=colors[i], edgecolor='black', linewidth=0.5)
        labels.append(f'{row["lad20nm"]}: {round(row[column], 2)}')

    # Create legend
    ax.legend(handles=[plt.Line2D([0], [0], color=colors[i], lw=4) for i in range(5)], labels=labels, loc='upper left', bbox_to_anchor=(1, 1))

    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    plt.title(title)
    plt.show()

"""# Institution Dataset"""

institution_dataset.info()

institution_dataset.isna.sum()

institution_dataset.describe()

institution_dataset.head()

institution_dataset['PROVADDRESS']

# Apply the function to the PROVADDRESS column to extract the outcode
institution_dataset['OUTCODE'] = institution_dataset['PROVADDRESS'].apply(extract_outcode)

institution_dataset=institution_dataset.drop(columns=["FIRST_TRADING_NAME", "OTHER_NAMES", "TEFOutcome",
                                                      "APROutcome", "SUURLW", "PROVTEL", "PROVURL", "PUBUKPRNCOUNTRY",
                                                      "SUURL", "PUBUKPRN"])

# Apply the function to the 'PROVADDRESS' column to extract postcodes
institution_dataset['POSTCODE'] = institution_dataset['PROVADDRESS'].apply(find_postcode)

# Display the first few rows of the dataset with the new 'POSTCODE' column
institution_dataset.head()

to_csv(institution_dataset, "institution_modified")

"""### Post Code Lookup Dataset

"""

pcd_dataset.head()

pcd_dataset.info()

pcd_dataset.isna().sum()

# Apply the function to the pcd8 column to extract outcode
pcd_dataset['OUTCODE'] = pcd_dataset['pcd8'].apply(extract_outcode)

pcd_dataset=pcd_dataset[["OUTCODE", "ladnm", "pcd7", "pcd8", "lsoa11cd", "ladcd", "msoa11cd", "oa11cd"]]

to_csv(pcd_dataset, "pcd_mapper")

!cp -r '/content/pcd_mapper.csv' '/content/drive/My Drive/Dissertation/pcd_mapper.csv'

pcd_dataset.info()

!pip install geopandas pandas matplotlib

"""# Utility Consumption - Consumption Table"""

data_year.info()

data_year.isna().sum()

# Defining the columns to extract
columns_to_extract = [
    'Local authority code',
    'Local authority',
    'LSOA code',
    'Total \nconsumption\n(kWh)',
    'Mean \nconsumption\n(kWh per meter)',
    'Median \nconsumption\n(kWh per meter)'
]

years_to_check = ["2015", "2016", "2017", "2018", "2019"]

# Extracting the specified columns for the years 2015 to 2019
extracted_data_2015_2019 = {}

for year in years_to_check:
    data_year = pd.read_excel("LSOA_domestic_elec_2010-21.xlsx", sheet_name=year, skiprows=4, usecols=columns_to_extract)
    extracted_data_2015_2019[year] = data_year

# Saving the extracted data to individual CSV files
for year, df in extracted_data_2015_2019.items():
    df.to_csv(f"extracted_data_{year}.csv", index=False)

import pandas as pd

# Load the data from the files
data_2015_16 = pd.read_csv("water_consumption_2015_16.csv")
data_2016_17 = pd.read_csv("water_consumption_2016_17.csv")
data_2017_18 = pd.read_csv("water_consumption_2017_18.csv")
data_2018_19 = pd.read_csv("water_consumption_2018_19.csv")
data_2019_20 = pd.read_csv("water_consumption_2019_20.csv")

# Merge datasets with the mapper to get the county names
data_2016_17_named = data_2016_17.merge(pcd_mapper, left_on='ladcd', right_on='LAD19CD', how='left')
data_2017_18_named = data_2017_18.merge(pcd_mapper, left_on='ladcd', right_on='LAD19CD', how='left')
data_2018_19_named = data_2018_19.merge(pcd_mapper, left_on='ladcd', right_on='LAD19CD', how='left')
data_2019_20_named = data_2019_20.merge(pcd_mapper, left_on='ladcd', right_on='LAD19CD', how='left')

# Concatenate all datasets
all_data = pd.concat([
    data_2016_17_named[['LAD19NM', 'Value']],
    data_2017_18_named[['LAD19NM', 'Value']],
    data_2018_19_named[['LAD19NM', 'Value']],
    data_2019_20_named[['LAD19NM', 'Value']]
])
# Group by county name and sum the values to get total consumption
total_consumption = all_data.groupby('LAD19NM').sum().reset_index()
# Sort by consumption to get top 5 areas
top_5_areas = total_consumption.sort_values(by='Value', ascending=False).head(5)
# Merge datasets with the mapper using the correct columns to get the county names
datasets_named = [dataset.merge(pcd_mapper[['ladcd', 'ladnm']], on='ladcd', how='left') for dataset in datasets]
# Concatenate all named datasets
all_data_named = pd.concat(datasets_named)
# Group by county name and sum the values to get total consumption
total_consumption_named = all_data_named.groupby('ladnm').sum().reset_index()
# Sort by consumption to get top 5 areas
top_5_areas_named = total_consumption_named.sort_values(by='Value', ascending=False).head(5)
# Sample a smaller subset of the mapper dataset to reduce memory consumption
sampled_mapper = pcd_mapper.sample(n=50000, random_state=42)
# Use the sampled mapper for the top areas function
top_2016_17 = top_areas_from_data(data_2016_17, sampled_mapper)
top_2017_18 = top_areas_from_data(data_2017_18, sampled_mapper)
top_2018_19 = top_areas_from_data(data_2018_19, sampled_mapper)
top_2019_20 = top_areas_from_data(data_2019_20, sampled_mapper)
# Aggregate top areas across years
all_top_areas = pd.concat([top_2016_17, top_2017_18, top_2018_19, top_2019_20])
aggregated_top_areas = all_top_areas.groupby(all_top_areas.index).sum()
# Get the final top 5 areas
final_top_5_approx = aggregated_top_areas.sort_values(by='Value', ascending=False).head(5)
final_top_5_approx

"""# IMD"""

df = pd.read_csv(file_path)

df.isna.sum()

# Define the relevant columns
relevant_columns = ['IMDScore', 'IncScore', 'EmpScore', 'EduScore', 'HDDScore', 'CriScore', 'BHSScore',
                    'EnvScore', 'CYPScore', 'ASScore', 'GBScore', 'WBScore', 'IndScore', 'OutScore']

# Load the shapefile into a GeoDataFrame
lad_boundaries = uk_gdf
# Display the first few rows of the GeoDataFrame
lad_boundaries.head()

# Group data by Local Authority District name (LADnm)
grouped_data = df.groupby('LADnm').mean()
# Merge the LAD boundaries with the socio-economic data
merged_data = lad_boundaries.merge(grouped_data, left_on='lad20nm', right_on='LADnm')

# Plot maps for top 5 LADs for each socio-economic factor with index scores and different colors
for col in relevant_columns:
    plot_top_5_map_updated_v2(merged_data, col, f'Top 5 LADs for {col}')

"""## Grades"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Filter and merge data
filtered_pcd_mapper_df = pcd_mapper[['OUTCODE', 'ladnm']].drop_duplicates()
merged_df = pd.merge(institution_grades_df, filtered_pcd_mapper_df, on='OUTCODE', how='left')

# Group data by LAD, academic year, and degree classification
grouped_df = merged_df.groupby(['ladnm', 'Academic Year', 'Level of qualification/Degree classification'])['Number'].sum().reset_index()

# Filter for specified degree classifications
degree_classifications = ['First class honours', 'Upper second class honours', 'Lower second class honours', 'Third class honours/Pass']
grouped_df = grouped_df[grouped_df['Level of qualification/Degree classification'].isin(degree_classifications)]

# Calculate percentages
grouped_df['Percentage'] = (grouped_df['Number'] / grouped_df.groupby('Academic Year')['Number'].transform('sum')) * 100

# Filter data for the specified academic years and LADs
selected_years = ['2015/16', '2016/17', '2017/18', '2018/19', '2019/20']
specified_lads = ['Westminster', 'Islington', 'Manchester', 'Birmingham']
filtered_grouped_df = grouped_df[grouped_df['Academic Year'].isin(selected_years) & grouped_df['ladnm'].isin(specified_lads)]

# Plot graphs
fig, axes = plt.subplots(nrows=len(specified_lads), figsize=(15, 20))
colors_map = dict(zip(degree_classifications, sns.color_palette('viridis', len(degree_classifications))))

for idx, lad in enumerate(specified_lads):
    ax = axes[idx]
    lad_data = filtered_grouped_df[filtered_grouped_df['ladnm'] == lad].pivot(index='Academic Year', columns='Level of qualification/Degree classification', values='Percentage')
    bars = lad_data.plot(kind='bar', stacked=True, ax=ax, color=[colors_map[col] for col in lad_data.columns])

    # Add percentage labels
    for bar_group in bars.containers:
        ax.bar_label(bar_group, label_type='edge', fontsize=8, padding=3, fmt='%.1f%%')

    ax.set_title(lad)
    ax.set_ylabel('Percentage (%)')
    ax.legend(title='Degree Classification', bbox_to_anchor=(1.05, 1), loc='upper left')
    ax.set_xticklabels(selected_years, rotation=45)  # Rotate x-axis labels for better visibility

plt.tight_layout()
plt.show()



"""# Marks Dataset"""

first_degree = pd.read_csv('table-16.csv')

first_degree.info()

# Merge the two DataFrames on the 'UKPRN' column
merged_df = pd.merge(first_degree, institution_dataset, on='UKPRN')

merged_df = merged_df.drop(columns=['SUURL', 'PUBUKPRNCOUNTRY', 'COUNTRY', 'PUBUKPRN', 'PROVADDRESS', 'LEGAL_NAME'])

to_csv(merged_df, "institution_grades")

"""# New"""

# Setting the style for the plots
sns.set_style("whitegrid")

"""# Energy-New - Sheffield"""

# Filter for Sheffield
sheffield_energy = merged_data[merged_data['Local authority'] == 'Sheffield']
sheffield_institutions = institution_modified[institution_modified['OUTCODE'].isin(pcd_mapper[pcd_mapper['ladnm'] == 'Sheffield']['OUTCODE'])]
sheffield_grades = institution_grades[institution_grades['UKPRN'].isin(sheffield_institutions['UKPRN'])]

# Filter the dataset for the specified academic years
specified_years = ['2015/16', '2016/17', '2017/18', '2018/19', '2019/20']
filtered_sheffield_grades = sheffield_grades[sheffield_grades['Academic Year'].isin(specified_years)]


# Plot Total Undergraduates and Postgraduates in Sheffield for the specified years
yearly_total_undergraduates = filtered_sheffield_grades[filtered_sheffield_grades['Level of qualification/Degree classification'] == 'Total undergraduate'].groupby('Academic Year')['Number'].sum()
yearly_total_postgraduates = filtered_sheffield_grades[filtered_sheffield_grades['Level of qualification/Degree classification'] == 'Total postgraduate'].groupby('Academic Year')['Number'].sum()

plt.figure(figsize=(8, 4))
yearly_total_undergraduates.plot(label='Undergraduates', color='Red', marker='o')
yearly_total_postgraduates.plot(label='Postgraduates', color='orange', marker='o')
plt.title('Total Undergraduates and Postgraduates in Sheffield Over the Years')
plt.xlabel('Academic Year')
plt.ylabel('Number of Students')
plt.legend()
plt.tight_layout()
plt.show()

# Plot Total Electricity Consumption in Sheffield Over the Years
yearly_electricity_consumption = sheffield_energy.groupby('Year')['Total \nconsumption\n(kWh)'].sum()
plt.figure(figsize=(8, 4))
yearly_electricity_consumption.plot(kind='line', color='purple', marker='o')
plt.title('Total Electricity Consumption in Sheffield Over the Years')
plt.xlabel('Year')
plt.ylabel('Total Consumption (kWh)')
plt.xticks(yearly_electricity_consumption.index, [str(int(year)) for year in yearly_electricity_consumption.index])
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.tight_layout()
plt.show()

# Merge datasets to create the combined_data DataFrame ensuring alignment by year
combined_data = pd.merge(
    pd.DataFrame({
        'Year': yearly_electricity_consumption.index.astype(str),
        'Electricity Consumption': yearly_electricity_consumption.values
    }),
    pd.DataFrame({
        'Year': yearly_total_undergraduates.index.astype(str),
        'Undergraduate': yearly_total_undergraduates.values,
        'Postgraduate': yearly_total_postgraduates.values
    }),
    on='Year',
    how='outer'
)

# Adjusting the 'Year' column for electricity consumption to match the academic year format
combined_data['Year'] = combined_data['Year'].apply(lambda x: f"{int(x)}/{int(x)+1}" if '/' not in x else x)

# Adjusting the 'Year' column for electricity consumption to the format "2015/2016"
combined_data['Year'] = combined_data['Year'].apply(lambda x: f"{x.split('/')[0]}/{int(x.split('/')[0])+1}" if '/' in x and len(x.split('/')[1]) == 2 else x)

# Grouping by 'Year' and summing up to combine similar academic years
aggregated_data = combined_data.groupby('Year').sum().reset_index()

# Filtering the data to only include the academic years from 2015/2016 to 2018/2019
filtered_data = aggregated_data[aggregated_data['Year'].isin(['2015/2016', '2016/2017', '2017/2018', '2018/2019', '2019/2020'])]

# Plotting the combined graph with synchronized x-axes for the adjusted academic years
fig, ax1 = plt.subplots(figsize=(8, 4))

# Plotting the student progression rates on the primary y-axis
ax1.plot(filtered_data['Year'], filtered_data['Postgraduate'], marker='o', color='blue', label='Postgraduate')
ax1.plot(filtered_data['Year'], filtered_data['Undergraduate'], marker='o', color='green', label='Undergraduate')
ax1.set_xlabel('Year')
ax1.set_ylabel('Number of Students', color='black')
ax1.tick_params(axis='y', labelcolor='black')
ax1.legend(loc='upper left')
ax1.set_title('Electricity Consumption vs. Student Progression Rates in Sheffield (2015/16-2019/2020)')

# Adjust x-axis to show unique year labels and synchronize with secondary axis
ax1.set_xticks(filtered_data['Year'].unique())

# Creating a secondary y-axis for the electricity consumption
ax2 = ax1.twinx()
ax2.plot(filtered_data['Year'], filtered_data['Electricity Consumption'], marker='o', color='red', linestyle='dashed', label='Electricity Consumption')
ax2.set_ylabel('Electricity Consumption (kWh)', color='red')
ax2.tick_params(axis='y', labelcolor='red')
ax2.legend(loc='upper right')

# Synchronize x-axes
ax2.set_xticks(ax1.get_xticks())

fig.tight_layout()
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.show()

"""# Manchester"""

# Filter for Sheffield
sheffield_energy = merged_data[merged_data['Local authority'] == 'Manchester']
sheffield_institutions = institution_modified[institution_modified['OUTCODE'].isin(pcd_mapper[pcd_mapper['ladnm'] == 'Manchester']['OUTCODE'])]
sheffield_grades = institution_grades[institution_grades['UKPRN'].isin(sheffield_institutions['UKPRN'])]

# Plot Total Undergraduates and Postgraduates in Sheffield Over the Years
yearly_total_undergraduates = sheffield_grades[sheffield_grades['Level of qualification/Degree classification'] == 'Total undergraduate'].groupby('Academic Year')['Number'].sum()
yearly_total_postgraduates = sheffield_grades[sheffield_grades['Level of qualification/Degree classification'] == 'Total postgraduate'].groupby('Academic Year')['Number'].sum()
plt.figure(figsize=(8, 4))
yearly_total_undergraduates.plot(label='Undergraduates', color='blue', marker='o')
yearly_total_postgraduates.plot(label='Postgraduates', color='orange', marker='o')
plt.title('Total Undergraduates and Postgraduates in Manchester Over the Years')
plt.xlabel('Academic Year')
plt.ylabel('Number of Students')
plt.legend()
plt.tight_layout()
plt.show()

# Plot Total Electricity Consumption in Sheffield Over the Years
yearly_electricity_consumption = sheffield_energy.groupby('Year')['Total \nconsumption\n(kWh)'].sum()
plt.figure(figsize=(8, 4))
yearly_electricity_consumption.plot(kind='line', color='purple', marker='o')
plt.title('Total Electricity Consumption in Manchester Over the Years')
plt.xlabel('Year')
plt.ylabel('Total Consumption (kWh)')
plt.xticks(yearly_electricity_consumption.index, [str(int(year)) for year in yearly_electricity_consumption.index])
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.tight_layout()
plt.show()

# Merge datasets to create the combined_data DataFrame ensuring alignment by year
combined_data = pd.merge(
    pd.DataFrame({
        'Year': yearly_electricity_consumption.index.astype(str),
        'Electricity Consumption': yearly_electricity_consumption.values
    }),
    pd.DataFrame({
        'Year': yearly_total_undergraduates.index.astype(str),
        'Undergraduate': yearly_total_undergraduates.values,
        'Postgraduate': yearly_total_postgraduates.values
    }),
    on='Year',
    how='outer'
)

# Adjusting the 'Year' column for electricity consumption to match the academic year format
combined_data['Year'] = combined_data['Year'].apply(lambda x: f"{int(x)}/{int(x)+1}" if '/' not in x else x)

# Adjusting the 'Year' column for electricity consumption to the format "2015/2016"
combined_data['Year'] = combined_data['Year'].apply(lambda x: f"{x.split('/')[0]}/{int(x.split('/')[0])+1}" if '/' in x and len(x.split('/')[1]) == 2 else x)

# Grouping by 'Year' and summing up to combine similar academic years
aggregated_data = combined_data.groupby('Year').sum().reset_index()

# Filtering the data to only include the academic years from 2015/2016 to 2018/2019
filtered_data = aggregated_data[aggregated_data['Year'].isin(['2015/2016', '2016/2017', '2017/2018', '2018/2019', '2019/2020'])]

# Plotting the combined graph with synchronized x-axes for the adjusted academic years
fig, ax1 = plt.subplots(figsize=(8, 4))

# Plotting the student progression rates on the primary y-axis
ax1.plot(filtered_data['Year'], filtered_data['Postgraduate'], marker='o', color='blue', label='Postgraduate')
ax1.plot(filtered_data['Year'], filtered_data['Undergraduate'], marker='o', color='green', label='Undergraduate')
ax1.set_xlabel('Year')
ax1.set_ylabel('Number of Students', color='black')
ax1.tick_params(axis='y', labelcolor='black')
ax1.legend(loc='upper left')
ax1.set_title('Electricity Consumption vs. Student Progression Rates in Manchester (2015/16-2018/2019)')

# Adjust x-axis to show unique year labels and synchronize with secondary axis
ax1.set_xticks(filtered_data['Year'].unique())

# Creating a secondary y-axis for the electricity consumption
ax2 = ax1.twinx()
ax2.plot(filtered_data['Year'], filtered_data['Electricity Consumption'], marker='o', color='red', linestyle='dashed', label='Electricity Consumption')
ax2.set_ylabel('Electricity Consumption (kWh)', color='red')
ax2.tick_params(axis='y', labelcolor='red')
ax2.legend(loc='upper right')

# Synchronize x-axes
ax2.set_xticks(ax1.get_xticks())

fig.tight_layout()
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.show()

"""# Birmingham"""

# Filter for Sheffield
sheffield_energy = merged_data[merged_data['Local authority'] == 'Birmingham']
sheffield_institutions = institution_modified[institution_modified['OUTCODE'].isin(pcd_mapper[pcd_mapper['ladnm'] == 'Birmingham']['OUTCODE'])]
sheffield_grades = institution_grades[institution_grades['UKPRN'].isin(sheffield_institutions['UKPRN'])]

# Plot Total Undergraduates and Postgraduates in Sheffield Over the Years
yearly_total_undergraduates = sheffield_grades[sheffield_grades['Level of qualification/Degree classification'] == 'Total undergraduate'].groupby('Academic Year')['Number'].sum()
yearly_total_postgraduates = sheffield_grades[sheffield_grades['Level of qualification/Degree classification'] == 'Total postgraduate'].groupby('Academic Year')['Number'].sum()
plt.figure(figsize=(8, 4))
yearly_total_undergraduates.plot(label='Undergraduates', color='blue', marker='o')
yearly_total_postgraduates.plot(label='Postgraduates', color='orange', marker='o')
plt.title('Total Undergraduates and Postgraduates in Birmingham Over the Years')
plt.xlabel('Academic Year')
plt.ylabel('Number of Students')
plt.legend()
plt.tight_layout()
plt.show()

# Plot Total Electricity Consumption in Sheffield Over the Years
yearly_electricity_consumption = sheffield_energy.groupby('Year')['Total \nconsumption\n(kWh)'].sum()
plt.figure(figsize=(8, 4))
yearly_electricity_consumption.plot(kind='line', color='purple', marker='o')
plt.title('Total Electricity Consumption in Birmingham Over the Years')
plt.xlabel('Year')
plt.ylabel('Total Consumption (kWh)')
plt.xticks(yearly_electricity_consumption.index, [str(int(year)) for year in yearly_electricity_consumption.index])
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.tight_layout()
plt.show()

# Merge datasets to create the combined_data DataFrame ensuring alignment by year
combined_data = pd.merge(
    pd.DataFrame({
        'Year': yearly_electricity_consumption.index.astype(str),
        'Electricity Consumption': yearly_electricity_consumption.values
    }),
    pd.DataFrame({
        'Year': yearly_total_undergraduates.index.astype(str),
        'Undergraduate': yearly_total_undergraduates.values,
        'Postgraduate': yearly_total_postgraduates.values
    }),
    on='Year',
    how='outer'
)

# Adjusting the 'Year' column for electricity consumption to match the academic year format
combined_data['Year'] = combined_data['Year'].apply(lambda x: f"{int(x)}/{int(x)+1}" if '/' not in x else x)

# Adjusting the 'Year' column for electricity consumption to the format "2015/2016"
combined_data['Year'] = combined_data['Year'].apply(lambda x: f"{x.split('/')[0]}/{int(x.split('/')[0])+1}" if '/' in x and len(x.split('/')[1]) == 2 else x)

# Grouping by 'Year' and summing up to combine similar academic years
aggregated_data = combined_data.groupby('Year').sum().reset_index()

# Filtering the data to only include the academic years from 2015/2016 to 2018/2019
filtered_data = aggregated_data[aggregated_data['Year'].isin(['2015/2016', '2016/2017', '2017/2018', '2018/2019', '2019/2020'])]

# Plotting the combined graph with synchronized x-axes for the adjusted academic years
fig, ax1 = plt.subplots(figsize=(8, 4))

# Plotting the student progression rates on the primary y-axis
ax1.plot(filtered_data['Year'], filtered_data['Postgraduate'], marker='o', color='blue', label='Postgraduate')
ax1.plot(filtered_data['Year'], filtered_data['Undergraduate'], marker='o', color='green', label='Undergraduate')
ax1.set_xlabel('Year')
ax1.set_ylabel('Number of Students', color='black')
ax1.tick_params(axis='y', labelcolor='black')
ax1.legend(loc='upper left')
ax1.set_title('Electricity Consumption vs. Student Progression Rates in Birmingham (2015/16-2018/2019)')

# Adjust x-axis to show unique year labels and synchronize with secondary axis
ax1.set_xticks(filtered_data['Year'].unique())

# Creating a secondary y-axis for the electricity consumption
ax2 = ax1.twinx()
ax2.plot(filtered_data['Year'], filtered_data['Electricity Consumption'], marker='o', color='red', linestyle='dashed', label='Electricity Consumption')
ax2.set_ylabel('Electricity Consumption (kWh)', color='red')
ax2.tick_params(axis='y', labelcolor='red')
ax2.legend(loc='upper right')

# Synchronize x-axes
ax2.set_xticks(ax1.get_xticks())

fig.tight_layout()
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.show()



"""# Residential and Non-residential Areas"""

sape_data.info()

# Filter data for Sheffield
sheffield_data = sape_data[sape_data['LA name (2019 boundaries)'] == 'Sheffield']

# Calculate total population aged 20-35 for each LSOA in Sheffield
sheffield_data['Population 20-35'] = sheffield_data.loc[:, list(range(20, 36))].sum(axis=1)

# Identify top populated areas based on the age range 20-35
top_populated_areas = sheffield_data[['LSOA Code', 'LSOA Name', 'Population 20-35']].sort_values(by='Population 20-35', ascending=False).head(10)


# Filter the electricity data based on the LSOA codes of the top populated areas
filtered_electricity_data = electricity_data[electricity_data['LSOA code'].isin(top_populated_areas['LSOA Code'])]

# Sum electricity consumption by year for these areas, excluding 2016.5
electricity_consumption_by_year_for_top_areas = filtered_electricity_data[filtered_electricity_data['Year'] != 2016.5].groupby(['Year', 'LSOA code'])['Total \nconsumption\n(kWh)'].sum().reset_index()

# Summing up the electricity consumption by year for all the top populated areas
total_electricity_consumption_by_year = electricity_consumption_by_year_for_top_areas.groupby('Year')['Total \nconsumption\n(kWh)'].sum().reset_index()

# Filtering out the data with half-year values (like 2015.5)
total_electricity_consumption_by_year = total_electricity_consumption_by_year[total_electricity_consumption_by_year['Year'].apply(lambda x: x % 1 != 0.5)]

# Plotting the adjusted electricity consumption by year
plt.figure(figsize=(12,7))
sns.lineplot(data=total_electricity_consumption_by_year, x='Year', y='Total \nconsumption\n(kWh)', marker='o')
plt.title('Total Electricity Consumption by Year for Top Populated Areas in Sheffield (Age 20-35)')
plt.xticks(total_electricity_consumption_by_year['Year'].astype(int))
plt.ylabel('Total Consumption (kWh)')
plt.xlabel('Year')
plt.grid(True)
plt.tight_layout()
plt.show()

"""# Performance"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt


# Filtering for Sheffield universities
sheffield_grades = institution_grades[institution_grades['HE provider'].str.contains('Sheffield', case=False, na=False)]
postgraduate_total_data_sheffield = sheffield_grades[sheffield_grades['Level of qualification/Degree classification'] == "Total postgraduate"]
undergraduate_total_data_sheffield = sheffield_grades[sheffield_grades['Level of qualification/Degree classification'] == "Total undergraduate"]

# Aggregating student numbers by academic year
postgraduate_total_by_year = postgraduate_total_data_sheffield.groupby('Academic Year')['Number'].sum().reset_index()
undergraduate_total_by_year = undergraduate_total_data_sheffield.groupby('Academic Year')['Number'].sum().reset_index()

# Adjusting the 'Year' columns for merging
postgraduate_total_by_year['Year'] = postgraduate_total_by_year['Academic Year'].apply(lambda x: int(x.split("/")[1]))
undergraduate_total_by_year['Year'] = undergraduate_total_by_year['Academic Year'].apply(lambda x: int(x.split("/")[1]))
electricity_data['Year'] = electricity_data['Year'].astype(int)

# Merging student data
merged_total_data = pd.merge(postgraduate_total_by_year, undergraduate_total_by_year, on='Year', how='outer', suffixes=('_postgraduate', '_undergraduate'))
# Merging with electricity data
combined_data = pd.merge(merged_total_data, electricity_data, on='Year', how='outer')

# Adjusting the 'Year' column for visualization
combined_data['Year'] = combined_data['Year'].apply(lambda x: f"{x-1}/{str(x)[-2:]}")

# Plotting the combined data
fig, ax1 = plt.subplots(figsize=(14, 8))
ax2 = ax1.twinx()
sns.lineplot(data=combined_data, x='Year', y='Postgraduates', ax=ax1, marker='o', label='Postgraduates')
sns.lineplot(data=combined_data, x='Year', y='Undergraduates', ax=ax1, marker='o', label='Undergraduates', linestyle='--')
sns.lineplot(data=combined_data, x='Year', y='Total \nconsumption\n(kWh)', ax=ax2, color='green', marker='o', label='Electricity Consumption')
ax1.set_xlabel('Academic Year')
ax1.set_ylabel('Number of Students', color='blue')
ax2.set_ylabel('Electricity Consumption (kWh)', color='green')
ax1.set_title('Total Postgraduates, Undergraduates, and Electricity Consumption by Academic Year for Sheffield')
ax1.grid(True)
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
plt.tight_layout()
plt.show()

sheffield_data['Population 20-35'].describe()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Filtering for Sheffield institutions using the pcd_mapper dataset
sheffield_institutions = institution_modified[institution_modified['OUTCODE'].isin(pcd_mapper[pcd_mapper['ladnm'] == 'Sheffield']['OUTCODE'])]

# Filtering for Sheffield grades
sheffield_grades = institution_grades[institution_grades['OUTCODE'].isin(sheffield_institutions['OUTCODE'])]

# Aggregating student numbers by academic year for postgraduates and undergraduates
postgraduate_total_by_year = sheffield_grades[sheffield_grades['Level of qualification/Degree classification'] == "Total postgraduate"].groupby('Academic Year')['Number'].sum().reset_index()
undergraduate_total_by_year = sheffield_grades[sheffield_grades['Level of qualification/Degree classification'] == "Total undergraduate"].groupby('Academic Year')['Number'].sum().reset_index()

# Adjusting the 'Year' columns for merging
postgraduate_total_by_year['Year'] = postgraduate_total_by_year['Academic Year'].apply(lambda x: int(x.split("/")[1]))
undergraduate_total_by_year['Year'] = undergraduate_total_by_year['Academic Year'].apply(lambda x: int(x.split("/")[1]))

# Merging student data
merged_total_data = pd.merge(postgraduate_total_by_year, undergraduate_total_by_year, on='Year', how='outer', suffixes=('_postgraduate', '_undergraduate'))

# Calculate electricity consumption for top 10 populated areas in Sheffield aged 20-35
sheffield_data = sape_data[sape_data['LA name (2019 boundaries)'] == 'Sheffield']
sheffield_data['Population 20-35'] = sheffield_data.loc[:, list(range(20, 36))].sum(axis=1)
top_populated_areas = sheffield_data[['LSOA Code', 'LSOA Name', 'Population 20-35']].sort_values(by='Population 20-35', ascending=False).head(15)
filtered_electricity_data = electricity_data[electricity_data['LSOA code'].isin(top_populated_areas['LSOA Code'])]
electricity_consumption_by_year_for_top_areas = filtered_electricity_data[filtered_electricity_data['Year'] != 2016.5].groupby(['Year', 'LSOA code'])['Total \nconsumption\n(kWh)'].sum().reset_index()
total_electricity_consumption_by_year = electricity_consumption_by_year_for_top_areas.groupby('Year')['Total \nconsumption\n(kWh)'].sum().reset_index()
total_electricity_consumption_by_year = total_electricity_consumption_by_year[total_electricity_consumption_by_year['Year'].apply(lambda x: x % 1 != 0.5)]
# Adjust electricity consumption years
total_electricity_consumption_by_year['Year'] = total_electricity_consumption_by_year['Year'].apply(
    lambda x: f"{x}/{str(x + 1)[-2:]}"
)

# Drop the 'Year' column in merged_total_data
merged_total_data.drop(columns='Year', inplace=True)

# Combine student data with electricity consumption data
combined_data = pd.merge(merged_total_data, total_electricity_consumption_by_year, left_on='Academic Year_postgraduate', right_on='Year', how='outer')

# Plot the combined data
fig, ax1 = plt.subplots(figsize=(14, 8))
ax2 = ax1.twinx()
sns.lineplot(data=combined_data, x='Year', y='Number_postgraduate', ax=ax1, marker='o', label='Postgraduates')
sns.lineplot(data=combined_data, x='Year', y='Number_undergraduate', ax=ax1, marker='o', label='Undergraduates', linestyle='--')
sns.lineplot(data=combined_data, x='Year', y='Total \nconsumption\n(kWh)', ax=ax2, color='green', marker='o', label='Electricity Consumption')
ax1.set_xlabel('Academic Year')
ax1.set_ylabel('Number of Students', color='blue')
ax2.set_ylabel('Electricity Consumption (kWh)', color='green')
ax1.set_title('Total Postgraduates, Undergraduates, and Electricity Consumption by Academic Year for Top Populated Areas in Sheffield (Age 20-35)')
ax1.grid(True)
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
plt.tight_layout()
plt.show()

# Calculate percentage change for postgraduates, undergraduates, and electricity consumption
combined_data['Number_postgraduate_percentage'] = combined_data['Number_postgraduate'].pct_change().fillna(0) * 100
combined_data['Number_undergraduate_percentage'] = combined_data['Number_undergraduate'].pct_change().fillna(0) * 100
combined_data['Total_consumption_percentage'] = combined_data['Total \nconsumption\n(kWh)'].pct_change().fillna(0) * 100

# Plot the original data
fig, ax1 = plt.subplots(figsize=(14, 8))
ax2 = ax1.twinx()
sns.lineplot(data=combined_data, x='Year', y='Number_postgraduate', ax=ax1, marker='o', label='Postgraduates')
sns.lineplot(data=combined_data, x='Year', y='Number_undergraduate', ax=ax1, marker='o', label='Undergraduates', linestyle='--')
sns.lineplot(data=combined_data, x='Year', y='Total \nconsumption\n(kWh)', ax=ax2, color='green', marker='o', label='Electricity Consumption')

# Annotate percentages on the lines
for idx, row in combined_data.iterrows():
    ax1.annotate(f"{row['Number_postgraduate_percentage']:.2f}%", (row['Year'], row['Number_postgraduate']), textcoords="offset points", xytext=(0,10), ha='center', fontsize=8)
    ax1.annotate(f"{row['Number_undergraduate_percentage']:.2f}%", (row['Year'], row['Number_undergraduate']), textcoords="offset points", xytext=(0,-15), ha='center', fontsize=8, color='blue')
    ax2.annotate(f"{row['Total_consumption_percentage']:.2f}%", (row['Year'], row['Total \nconsumption\n(kWh)']), textcoords="offset points", xytext=(0,10), ha='center', fontsize=8, color='green')

# Set labels and title
ax1.set_xlabel('Academic Year')
ax1.set_ylabel('Number of Students', color='blue')
ax2.set_ylabel('Electricity Consumption (kWh)', color='green')
ax1.set_title('Total Postgraduates, Undergraduates, and Electricity Consumption by Academic Year for Top Populated Areas in Sheffield (Age 20-35)')
ax1.grid(True)
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
plt.tight_layout()
plt.show()

# Calculating the correlation matrix for number of postgraduates, undergraduates, and total electricity consumption
correlation_matrix_attainment = combined_data[['Number_postgraduate', 'Number_undergraduate', 'Total \nconsumption\n(kWh)']].corr()

# Calculating Spearman and Kendall correlation matrices
spearman_corr = combined_data[['Number_postgraduate', 'Number_undergraduate', 'Total \nconsumption\n(kWh)']].corr(method='spearman')
kendall_corr = combined_data[['Number_postgraduate', 'Number_undergraduate', 'Total \nconsumption\n(kWh)']].corr(method='kendall')

spearman_corr



"""# EDA - Institution Grades"""

import pandas as pd

# Load the dataset
df = pd.read_csv("institution_grades (1).csv")

# Checking the data types and basic statistics for each column
data_info = df.info()

# Checking for missing values
missing_values = df.isnull().sum()

missing_values

import matplotlib.pyplot as plt
import seaborn as sns

# Setting the style for the plots
sns.set_style("whitegrid")

# Grouping by 'Country of HE provider', 'Academic Year' and summing the 'Number'
country_yearly_counts = df.groupby(['Country of HE provider', 'Academic Year'])['Number'].sum().unstack()

# Plotting the stacked bar plot for distribution across countries for each academic year
plt.figure(figsize=(14, 8))
country_yearly_counts.T.plot(kind='bar', stacked=True, figsize=(14, 8), colormap='tab10')
plt.title('Distribution of Students/Graduates Across Countries for Each Academic Year')
plt.xlabel('Academic Year')
plt.ylabel('Total Number of Students/Graduates')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend(title='Country of HE Provider', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Load the data
population_data = sape_data

# Filter the data for Sheffield
sheffield_population_data = population_data[population_data['LA name (2019 boundaries)'] == 'Sheffield']

# Extract the population counts for ages 20 to 35 for Sheffield
age_columns = list(range(20, 36))
sheffield_population_by_age = sheffield_population_data.iloc[:, 22:38].sum()

# Visualize the age-specific population counts for Sheffield
plt.figure(figsize=(14, 8))
sheffield_population_by_age.plot(kind='bar', color='salmon')
plt.title('Population Distribution in Sheffield for Ages 20 to 35 (2019)')
plt.xlabel('Age')
plt.ylabel('Population Count')
plt.xticks(ticks=range(len(age_columns)), labels=age_columns, rotation=0)
plt.grid(True, axis='y', linestyle='--', linewidth=0.5, alpha=0.7)
plt.tight_layout()
plt.show()

# Correcting the visualization of age-specific population counts for Sheffield with labels
plt.figure(figsize=(14, 8))
bars = plt.bar(sheffield_population_by_age.index.astype(str), sheffield_population_by_age.values, color='salmon')

# Adding labels to the bars
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval - 5000, int(yval), ha='center', va='top', fontsize=10, color='white', weight='bold')

plt.title('Population Distribution in Sheffield for Ages 20 to 35 (2019)')
plt.xlabel('Age')
plt.ylabel('Population Count')
plt.xticks(ticks=sheffield_population_by_age.index.astype(str), labels=sheffield_population_by_age.index.astype(str), rotation=0)
plt.grid(True, axis='y', linestyle='--', linewidth=0.5, alpha=0.7)
plt.tight_layout()
plt.show()

# Load the LSOA shapefile
lsoa_shape_data = gpd.read_file('LSOA_2011_EW_BGC_V3.shp')

# Load and process the population data

population_data = sape_data
# ... (any necessary processing on the population data)
# Aggregate the population counts for ages 20 to 35 for each local authority
population_data['population_20_35'] = population_data.iloc[:, 22:38].sum(axis=1)

# Merge the LSOA shape data with the population data
merged_lsoa_data = lsoa_shape_data.merge(population_data, left_on='LSOA11NM', right_on='LSOA Name', how='left')

# Filter for LSOAs within Sheffield
sheffield_lsoa_merged_data = merged_lsoa_data[merged_lsoa_data['LA name (2019 boundaries)'] == 'Sheffield']

# Get the top 10 LSOAs based on population for ages 20-35
top_10_lsoas = sheffield_lsoa_merged_data.nlargest(15, 'population_20_35')

# Plotting the choropleth map
fig, ax = plt.subplots(1, 1, figsize=(15, 15))
sheffield_lsoa_merged_data.plot(column='population_20_35', ax=ax, cmap='YlOrRd', edgecolor='black', linewidth=0.5)

# Annotate the map with population counts
for x, y, label in zip(sheffield_lsoa_merged_data.geometry.centroid.x, sheffield_lsoa_merged_data.geometry.centroid.y, sheffield_lsoa_merged_data['population_20_35']):
    ax.text(x, y, str(int(label)), fontsize=8, ha='center', va='center', color='black')

# Create a custom legend for the top 10 LSOAs
legend_labels = [f"{row['LSOA11CD']} (Count: {int(row['population_20_35'])})" for _, row in top_10_lsoas.iterrows()]
legend_colors = [plt.cm.YlOrRd(row['population_20_35'] / sheffield_lsoa_merged_data['population_20_35'].max()) for _, row in top_10_lsoas.iterrows()]
patches = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10) for color in legend_colors]
legend = ax.legend(handles=patches, labels=legend_labels, loc='upper left', title='Top 10 LSOAs by Population', frameon=True, borderpad=1, labelspacing=1.5)
frame = legend.get_frame()
frame.set_facecolor('white')
frame.set_edgecolor('black')

# Final adjustments and display
plt.title('Population Distribution by LSOA in Sheffield for Ages 20-35 (2019)')
plt.axis('off')
plt.tight_layout()
plt.show()

import pandas as pd

# Load the datasets

universities = pd.read_csv('institution_modified.csv')

# Drop rows with missing OUTCODE values from pcd_mapper
pcd_mapper = pcd_mapper.dropna(subset=['OUTCODE'])

# Filter pcd_mapper for rows relevant to Sheffield based on OUTCODE prefix "S"
filtered_sheffield_pcd_mapper = pcd_mapper[pcd_mapper['OUTCODE'].str.startswith('S')]

# Extract unique OUTCODEs corresponding to Sheffield from the filtered pcd_mapper
sheffield_outcodes = filtered_sheffield_pcd_mapper['OUTCODE'].unique()

# Extract unique LSOA codes corresponding to Sheffield's outcodes
sheffield_lsoas = filtered_sheffield_pcd_mapper['lsoa11cd'].unique()

# Check the universities data to see if any of these OUTCODEs are present
universities_in_sheffield = universities[universities['OUTCODE'].isin(sheffield_outcodes)]

# Display the universities in Sheffield
universities_in_sheffield[['LEGAL_NAME', 'OUTCODE']]

sheffield_population_data = sape_data

# Filter pcd_mapper for rows relevant to Sheffield based on OUTCODE prefix "S"
filtered_sheffield_pcd_mapper = pcd_mapper[pcd_mapper['OUTCODE'].str.startswith('S', na=False)]

# Extract unique LSOA codes corresponding to Sheffield's outcodes
sheffield_lsoas = filtered_sheffield_pcd_mapper['lsoa11cd'].unique()

# Calculate total population count for individuals aged 20-35 for each LSOA
sheffield_population_data['population_20_35'] = sheffield_population_data.loc[:, 20:35].sum(axis=1)

# Extract the LSOA codes for the top populated areas
top_lsoas_population = sheffield_population_data.nlargest(20, 'population_20_35').reset_index()

# Extract the OUTCODEs for the top populated LSOAs
top_outcodes_population = filtered_sheffield_pcd_mapper[filtered_sheffield_pcd_mapper['lsoa11cd'].isin(top_lsoas_population['LSOA Code'])]['OUTCODE'].unique()

# Check if the OUTCODEs of the universities are in the top populated OUTCODEs
universities_in_top_populated_areas = universities[universities['OUTCODE'].isin(top_outcodes_population)]

universities_in_top_populated_areas[['LEGAL_NAME', 'OUTCODE']]

# Check presence of Sheffield Hallam University and The University of Sheffield in the universities DataFrame
specific_universities = universities[universities['LEGAL_NAME'].isin(['Sheffield Hallam University', 'The University of Sheffield'])]
specific_universities[['LEGAL_NAME', 'OUTCODE']]

sape22_data_persons = sape_data
postcode_mapper = pcd_mapper
institutions_data = pd.read_csv('institution_modified.csv')

# import pandas as pd
# import geopandas as gpd
# import matplotlib.pyplot as plt



# # Filter data to get only Sheffield entries
# sheffield_data = sape22_data_persons[sape22_data_persons['LA name (2019 boundaries)'] == 'Sheffield']

# # Merge Sheffield data with boundaries for visualization
# sheffield_boundaries_merged = sheffield_boundaries.merge(sheffield_data, left_on='LSOA11CD', right_on='LSOA Code')

# # Filtering universities in Sheffield by 'OUTCODE'
# sheffield_universities = institutions_data[institutions_data['OUTCODE'].fillna('').str.startswith('S')]
# sheffield_universities_by_lsoa = sheffield_universities.merge(postcode_mapper, left_on='OUTCODE', right_on='OUTCODE').drop_duplicates(subset=['LEGAL_NAME'])

# # Visualizing the population distribution by LSOA in Sheffield and annotating university LSOAs
# fig, ax = plt.subplots(1, 1, figsize=(15, 15))
# sheffield_boundaries_merged.plot(column='population_20_35', ax=ax, cmap='YlOrRd', edgecolor='black', linewidth=0.5, legend=True)

# # Annotating the university LSOAs with arrows for clearer visualization
# for _, row in sheffield_universities_by_lsoa.iterrows():
#     ax.annotate(row['LEGAL_NAME'],
#                 xy=(row.geometry.centroid.x, row.geometry.centroid.y),
#                 xytext=(row.geometry.centroid.x + 0.01, row.geometry.centroid.y + 0.01),
#                 fontsize=10, color='blue', ha='center',
#                 arrowprops=dict(facecolor='blue', arrowstyle='->', lw=1))

# plt.title('Population Distribution by LSOA in Sheffield for Ages 20-35 (2019) with University LSOAs')
# plt.axis('off')
# plt.tight_layout()
# plt.show()

# Identify Sheffield OUTCODEs from the pcd_mapper
sheffield_outcodes = pcd_mapper[pcd_mapper['ladnm'] == 'Sheffield']['OUTCODE'].unique()

# Filter the main dataset using Sheffield OUTCODEs
sheffield_data_outcode_mapped = df[df['OUTCODE'].isin(sheffield_outcodes)]

# Aggregate the number of "Total postgraduate" in Sheffield across academic years based on OUTCODE mapping
sheffield_total_postgrad_by_year = sheffield_data_outcode_mapped[sheffield_data_outcode_mapped['Level of qualification/Degree classification'] ==
                                                                 'Total postgraduate'].groupby('Academic Year')['Number'].sum()

# Visualize the trend
plt.figure(figsize=(12, 6))
sns.lineplot(x=sheffield_total_postgrad_by_year.index, y=sheffield_total_postgrad_by_year.values, marker="o", color="blue")
plt.title('Trend of Postgraduate Achievement Counts in Sheffield Across Academic Years')
plt.xlabel('Academic Year')
plt.ylabel('Number of Postgraduates')
plt.xticks(rotation=45)
plt.tight_layout()
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.show()

# Load the merged electricity consumption data
merged_data = pd.read_csv('merged_data_2015_2019.csv')

# Aggregate the total electricity consumption for each LSOA from 2015-2019
total_electricity_consumption = merged_data.groupby('LSOA code')['Total \nconsumption\n(kWh)'].sum().reset_index()

# Filter the data for LSOAs in Sheffield for the year 2019
sheffield_electricity_2019 = merged_data[merged_data['Year'] == 2019]
sheffield_electricity_2019 = sheffield_electricity_2019[sheffield_electricity_2019['Local authority'] == 'Sheffield']

# Filter the aggregated data for LSOAs in Sheffield
sheffield_total_consumption = total_electricity_consumption[total_electricity_consumption['LSOA code'].isin(sheffield_electricity_2019['LSOA code'])]

# Load the Sheffield LSOA boundary data
sheffield_boundaries = gpd.read_file("LSOA_2011_EW_BGC_V3.shp")

# Merge the boundary data with the total electricity consumption data
sheffield_consumption_merged = sheffield_boundaries.merge(sheffield_total_consumption, left_on='LSOA11CD', right_on='LSOA code')

# Plotting the choropleth map based on total electricity consumption from 2015-2019
fig, ax = plt.subplots(1, 1, figsize=(15, 15))
sheffield_consumption_merged.plot(column='Total \nconsumption\n(kWh)', ax=ax, cmap='YlOrRd', edgecolor='black', linewidth=0.5, legend=True)
plt.title('Total Electricity Consumption by LSOA in Sheffield (2015-2019)')
plt.axis('off')
plt.tight_layout()
plt.show()

# Load the merged electricity consumption data
merged_data = pd.read_csv('merged_data_2015_2019.csv')

# Aggregate the total electricity consumption for each LSOA from 2015-2019
total_electricity_consumption = merged_data.groupby('LSOA code')['Total \nconsumption\n(kWh)'].sum().reset_index()

# Filter the data for LSOAs in Sheffield for the year 2019
sheffield_electricity_2019 = merged_data[merged_data['Year'] == 2019]
sheffield_electricity_2019 = sheffield_electricity_2019[sheffield_electricity_2019['Local authority'] == 'Sheffield']

# Filter the aggregated data for LSOAs in Sheffield
sheffield_total_consumption = total_electricity_consumption[total_electricity_consumption['LSOA code'].isin(sheffield_electricity_2019['LSOA code'])]

# Load the Sheffield LSOA boundary data
sheffield_boundaries = gpd.read_file("LSOA_2011_EW_BGC_V3.shp")

# Merge the boundary data with the total electricity consumption data
sheffield_consumption_merged = sheffield_boundaries.merge(sheffield_total_consumption, left_on='LSOA11CD', right_on='LSOA code')

# Extract the top 10 LSOAs based on total electricity consumption
top_10_sheffield_lsoas = sheffield_total_consumption.sort_values(by='Total \nconsumption\n(kWh)', ascending=False).head(10)

# Adjusting the legend creation by avoiding f-string for column with newline characters
legend_labels = [row['LSOA code'] + " (Consumption: " + str(int(row['Total \nconsumption\n(kWh)'])) + ")" for _, row in top_10_sheffield_lsoas.iterrows()]

# Recreate legend colors and patches for the top 10 LSOAs
legend_colors = [plt.cm.YlOrRd(row['Total \nconsumption\n(kWh)'] / sheffield_consumption_merged['Total \nconsumption\n(kWh)'].max()) for _, row in top_10_sheffield_lsoas.iterrows()]
patches = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10) for color in legend_colors]

# Plotting the choropleth map based on total electricity consumption from 2015-2019
fig, ax = plt.subplots(1, 1, figsize=(15, 15))
sheffield_consumption_merged.plot(column='Total \nconsumption\n(kWh)', ax=ax, cmap='YlOrRd', edgecolor='black', linewidth=0.5, legend=True)

# Create a custom legend for the top 10 LSOAs
legend = ax.legend(handles=patches, labels=legend_labels, loc='upper left', title='Top 10 LSOAs by Consumption', frameon=True, borderpad=1, labelspacing=1.5)
frame = legend.get_frame()
frame.set_facecolor('white')
frame.set_edgecolor('black')

# Final adjustments and display
plt.title('Total Electricity Consumption by LSOA in Sheffield (2015-2019)')
plt.axis('off')
plt.tight_layout()
plt.show()

# Re-load the dataset
institution_grades = pd.read_csv("institution_grades (1).csv")

# Inspect the first few rows of the dataset
institution_grades.head()

# Checking the dataset's structure, data types, and missing values
dataset_info = institution_grades.info()

# Checking for missing values in each column
missing_values = institution_grades.isnull().sum()

dataset_info, missing_values

# Visualizing the distribution of students across different qualification levels
plt.figure(figsize=(12, 8))
sns.barplot(y=institution_grades['Level of qualification/Degree classification'].value_counts().index,
            x=institution_grades['Level of qualification/Degree classification'].value_counts().values,
            palette="viridis")
plt.title('Distribution of Students Across Different Qualification Levels', fontsize=16)
plt.xlabel('Number of Students', fontsize=14)
plt.ylabel('Qualification Level', fontsize=14)
plt.tight_layout()
plt.show()

# Visualizing the distribution of HE providers across different regions
plt.figure(figsize=(10, 6))
sns.countplot(y=institution_grades['Region of HE provider'], order=institution_grades['Region of HE provider'].value_counts().index, palette="coolwarm")
plt.title('Distribution of HE Providers Across Regions', fontsize=16)
plt.xlabel('Number of HE Providers', fontsize=14)
plt.ylabel('Region', fontsize=14)
plt.tight_layout()
plt.show()

# Visualizing the distribution of HE providers across different countries
plt.figure(figsize=(8, 4))
sns.countplot(y=institution_grades['Country of HE provider'], order=institution_grades['Country of HE provider'].value_counts().index, palette="Pastel1")
plt.title('Distribution of HE Providers Across Countries', fontsize=16)
plt.xlabel('Number of HE Providers', fontsize=14)
plt.ylabel('Country', fontsize=14)
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Load the dataset
merged_data = pd.read_csv("merged_data_2015_2019.csv")

# Filtering the data for Sheffield
sheffield_merged_data = merged_data[merged_data['Local authority'].str.contains("Sheffield", na=False)]

# Summing up the total electricity consumption in Sheffield for each year
sheffield_total_consumption = sheffield_merged_data.groupby('Year')['Total \nconsumption\n(kWh)'].sum()

# Line chart for total electricity consumption in Sheffield (2015-2019)
plt.figure(figsize=(10, 6))
sheffield_total_consumption.plot(kind='line', marker='o', color='darkred', linewidth=2)
plt.title('Total Electricity Consumption in Sheffield (2015-2019)', fontsize=16)
plt.xlabel('Year', fontsize=14)
plt.ylabel('Total Consumption (kWh)', fontsize=14)
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.tight_layout()
plt.show()

